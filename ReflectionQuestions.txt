    • How did you test your if or while control structure?
      
      How we checked if/else: To test the if statement, we just put the word if in the input file, followed by a basic expression like x + 5. When Flex saw if, the code we wrote printed "Keyword: IF". To mimic how an if works, we just manually set a flag (if_condition_result) to 1 (meaning true). This made the program process the lines of code right after the if. When it hit the else keyword later, our code checked that flag. Since it was 1, it printed "Skipping ELSE block", which is what you'd expect. If we'd wanted to test the else part, we could have just changed the code to set the flag to 0 (false) back in the if section, and then the else part would have printed "Entering ELSE block". This was basically just checking if Flex could spot the keywords and if our simple true/false logic simulation worked.
      
      How we checked while: Testing while was even simpler. We put while followed by something like count in the input. The code tied to the while rule just prints "Keyword: WHILE". That's pretty much it. With just Flex, we couldn't actually make it loop. It just confirmed it recognized the while keyword. For a real while loop, you'd need a proper parser to handle checking the condition and repeating the code block.
      
    • What challenges did you face in designing your input/output?
	
	Figuring Out the Order of Operations: The main headache we found was that Flex just 	reads things one token at a time, left to right. It doesn't naturally understand things like 	multiplication needing to happen before addition (3 + 4 * 2) or how code blocks nest 	inside each other. To handle basic math, we used a simple stack in our C code actions. When 	it saw an operator, it would immediately try to perform the calculation with the numbers 	already on the stack. This works okay for simple stuff or if you write expressions backward 	(like postfix), but it falls apart for regular math equations.

      Faking Control Flow: Making if/else or while actually control the program flow is tough with just Flex. It can spot the keywords, sure, but making it skip a block of code (if/else) or repeat one (while) is tricky. It's not really what Flex is built for. We ended up using some global flags (like if_condition_result) to kind of fake it, but it's a clunky workaround and wouldn't scale well for anything complex. That's really a job for a parser (like Bison or Yacc), which understands the code's structure.
      Getting Useful Output: It was hard for us to decide what the program should print out. Just printing the names of the tokens Flex found isn't very helpful. So, we added printf statements inside the actions to show what was happening, like "-> Evaluated: ..." or "-> Skipping ELSE block...". This made it easier to follow, but it also made the output pretty noisy. Finding the right balance between clear feedback and too much detail was tricky.
      Handling Variable Assignment (=): Getting assignment to work reliably was difficult. Our simple approach kind of assumed the value to be assigned was already figured out and on the stack, and the variable name was the token right before the =. This breaks easily for common things like x = y + 5. For assignment to work correctly, you really need a parser to understand that the variable x gets the result of the whole y + 5 expression. It needs to build a structure (like an Abstract Syntax Tree) to get the relationships right.

