How did you test your if or while control structure?
      
Checking the if structure:
        ◦ Testing the if block: We looked at the sample input where z gets calculated as 10 * 2 + 5, which works out to 25. The condition was if (z > 20), and since 25 is definitely greater than 20, that's true. We confirmed this by checking the trace output – it clearly showed the condition was true, the print z; line inside the if block ran (printing 25), and, just as importantly, the else block was skipped. So, that part worked as expected. 
        ◦ Testing the else block: We didn't have a sample input that specifically tested the else part, but if we needed to, we'd just tweak the input to make the if condition false. For example, changing the calculation to z = x * y - 10; would make z equal to 10. Then, running it again, we'd expect the trace to show the if condition (10 > 20) as false, the if block getting skipped, and the code inside the else block (like print x;) running instead. 
          
Checking the while structure:
        ◦ The sample input set i to 0 and used the condition while (i < 3). Looking at the trace, we saw the condition 0 < 3 evaluated to true, and the code inside the loop (print i; i = i + 1;) ran once. 
        ◦ However, as the warning message in the code pointed out, the big limitation here is that our Flex-only setup just checks the while condition and runs the block one time. It doesn't actually loop back to check the condition again like a real while loop should. Our testing confirmed it just did this single pass, not proper iteration. 

    • Managing State: Keeping track of what was going on across different Flex rules got complicated quickly. For instance, knowing whether a variable name (IDENTIFIER) was the one being assigned to (on the left of =), or if it was being used in a calculation (on the right), or part of a condition, required careful use of flags (isAssignment) and temporary variables to remember the context. When we got this state management wrong, it caused a lot of the bugs we saw during debugging, like variables getting the wrong values or the stack getting messed up.
      
      

What challenges did you face in designing your input/output?
    • Faking Control Flow in Flex: Honestly, the biggest headache was trying to force Flex to handle control structures like if-else and while. Flex is great at spotting keywords and symbols (lexical stuff), but it's not really built for understanding grammar or managing the state needed to jump between code blocks or loop. This meant we had to stuff a lot of C code and logic right into the Flex actions themselves. We ended up using helper variables (like skipCodeBlock, conditionResult) and even Flex's start conditions (<SKIP_BLOCK>, etc.) just to manage where the program should be reading or skipping. It felt complicated, was harder to debug, and definitely isn't as clean or reliable as using a proper parser tool like Bison would be.
    • Basic Math Evaluation: Even getting simple calculations like z = x * y + 5 to work right without a parser was tricky. Our code used a basic stack and pretty much evaluated things as it saw them. This worked for the specific sample, but it completely ignores standard math rules like operator precedence (multiply before add) or how parentheses should work. Making sure we were pushing and popping numbers off the stack correctly, especially around assignment (=), took a fair bit of debugging.
    • Designing the Input Language: We needed to come up with a simple format for the input code (using $, ;, { }, ( )) that Flex could break down into tokens without getting confused. If the input format was ambiguous, Flex could easily mess up the tokenizing, leading to wrong results.
    • Formatting the Output: Figuring out the right level of detail for the trace output was a balancing act. We wanted it to be clear enough to show what was happening – variable values changing, which way an if went, calculation results – but not so cluttered that it was impossible to read. We tweaked what information to print a few times to get it reasonably helpful for debugging.
